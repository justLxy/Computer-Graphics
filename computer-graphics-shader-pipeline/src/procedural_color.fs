// Set the pixel color to an interesting procedural color generated by mixing
// and filtering Perlin noise of different frequencies.
//
// Uniforms:
uniform mat4 view;
uniform mat4 proj;
uniform float animation_seconds;
uniform bool is_moon;
// Inputs:
in vec3 sphere_fs_in;
in vec3 normal_fs_in;
in vec4 pos_fs_in; 
in vec4 view_pos_fs_in; 
// Outputs:
out vec3 color;

// expects: blinn_phong, perlin_noise
void main()
{
  /////////////////////////////////////////////////////////////////////////////
  vec3 pos = sphere_fs_in;
  
  float noise1 = perlin_noise(pos * 4.0);
  float noise2 = perlin_noise(pos * 8.0);
  float noise3 = perlin_noise(pos * 16.0);
  
  float turbulence = noise1 * 0.5 + noise2 * 0.25 + noise3 * 0.125;
  
  float marble = sin(pos.x * 5.0 + turbulence * 5.0);
  marble = 0.5 + 0.5 * marble;
  
  // Set up lighting
  float light_angle = animation_seconds * 2.0 * M_PI / 8.0;
  vec3 light_pos = vec3(4.0 * cos(light_angle), 2.0, 4.0 * sin(light_angle));
  vec3 light_dir = normalize((view * vec4(light_pos, 1.0)).xyz - view_pos_fs_in.xyz);
  vec3 view_dir = normalize(-view_pos_fs_in.xyz);
  
  // Material colors based on marble pattern
  vec3 base_color;
  if (is_moon) {
    base_color = mix(vec3(0.3, 0.3, 0.3), vec3(0.8, 0.8, 0.8), marble);
  } else {
    base_color = mix(vec3(0.1, 0.2, 0.4), vec3(0.7, 0.8, 0.9), marble);
  }
  
  vec3 ka = base_color * 0.2;
  vec3 kd = base_color * 0.8;
  vec3 ks = vec3(0.3, 0.3, 0.3);
  float phong_exp = 50.0;
  
  color = blinn_phong(ka, kd, ks, phong_exp, normalize(normal_fs_in), view_dir, light_dir);
  /////////////////////////////////////////////////////////////////////////////
}
